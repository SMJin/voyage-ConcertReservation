# 🦢 Redis 와 분산락(Distributed Lock)

## 🦢 필수 사전 정보
### 🦆 SETNX
- **SETNX**: "Set if Not eXists"의 약자로, Redis에서 `키가 존재하지 않을 때만 값을 설정`하는 명령어이다.
- 주로 **분산 락**을 구현할 때 사용되며, 락을 선점하는 데 사용된다.
### 🦆 TTL
- **TTL**: "Time To Live"의 약자로, Redis 키에 `자동 만료 시간`을 설정하는 기능이다.
- 주로 락이 무한히 유지되는 것을 방지하기 위해, **분산 락**의 만료 시간을 설정하는 데 사용된다.
- 예를 들어, `EXPIRE` 명령어를 사용하여 키의 만료 시간을 설정할 수 있다.
- `PX 옵션`을 사용하면 `밀리초` 단위로 만료 시간을 설정할 수 있다.
### 🦆 Redisson
- `Java용 Redis 클라이언트 라이브러리`로, **분산 락, 세마포어, 큐** 등 고급 구조를 제공한다.
- `tryLock`, `fairLock` 등의 메서드를 통해 분산 락을 쉽게 구현할 수 있다.
- **watchdog** 기능을 통해 락이 자동으로 연장되며, 내부적으로 **SETNX + TTL + Lua 스크립트**를 사용하여 안전하게 락을 관리한다.
- 예를 들어, `RLock` 인터페이스를 통해 락을 획득하고 해제할 수 있다.
- Redisson은 Redis의 분산 락을 구현하기 위한 **고급 API**를 제공하여, 개발자가 직접 Redis 명령어를 작성하지 않고도 쉽게 사용할 수 있다.
### 🦆 Lua 스크립트
- Redis에서 여러 명령을 하나의 트랜잭션처럼 원자적으로 실행하기 위해 사용하는 내장 스크립트 언어이다.
- Redis는 MULTI/EXEC로 트랜잭션처럼 묶을 수 있지만, 완전한 원자성 보장이나 조건문, 반복문 같은 로직 처리는 부족하다.
- 그래서 Redis는 Lua라는 경량 스크립트 언어를 내장해서, 복잡한 작업을 한 번에 처리할 수 있게 했다.
##### 예제: 락 해제 시 락 주인 확인
```Lua
if redis.call("get", KEYS[1]) == ARGV[1] then
  return redis.call("del", KEYS[1])
else
  return 0
end
```
- 이걸 Redis 명령으로 직접 처리하려면 get → if → del이 분리
- Lua로 작성하면 한 번에 원자적으로 처리 가능

## 🦢 Redis 의 락 방식에 대해서
| 방식                                | 설명                        | 사용 예시           | 장점               | 단점                  |
|-----------------------------------|---------------------------|-----------------|------------------|---------------------|
| **1. SETNX + TTL (Simple Lock)**  | `SET key value NX PX ttl` | 간단한 분산락         | 구현 간단, 빠름        | 락 소유자 확인 없이 삭제 시 위험 |
| **2. Spin Lock**                  | 락 획득 실패 시 **반복 재시도**      | 짧은 시간 내 재도전     | 락 획득 확률 높음       | Redis 부하, CPU 낭비    |
| **3. Lua 기반 Safe Unlock**         | 락 해제 시 **소유자 확인 후 삭제**    | 락을 가진 주체만 해제 가능 | 안전한 락 해제         | Lua 이해 필요           |
| **4. Redisson Lock (Pub-Sub 기반)** | Redisson에서 제공하는 **고수준 락** | 실서비스에서 가장 안정적   | 자동 연장, 클러스터 지원   | 외부 라이브러리 필요         |
| **5. RedLock (다중 Redis 노드 락)**    | 여러 Redis 노드에 락 분산 획득      | 고가용성 락 필요 시     | 장애 대응, 다중 노드 안정성 | 구현 복잡, 논란 있음        |

## 🦢 Redis 의 락 방식에 대해서 - 나의 언어로 간단 명료 정리
### 🦆 1. SETNX + TTL (Simple Lock)
- `기본`적인 Redis 가 제공하는 분산 락 방식
- `SETNX` 명령어로 락을 획득하고, `TTL`로 만료 시간을 설정
### 🦆 2. Spin Lock
- Simple Lock 을 사용하면서, 락 획득 실패 시 **반복 재시도**하는 방식
- 반복 재시도 로직은 따로 Redis 에서 제공하는게 아니라, 개발자가 직접 구현해야 함
- 즉, `Simple Lock 위에 반복문, 조건문을 끼얹은` 것.
### 🦆 3. Lua 기반 Safe Unlock
- `커스텀하고 예민한 로직`이 필요할 때 사용
- VIP는 기존 락을 무시하고 획득한다거나
- 사용자별 할당량에 따라 락을 획득한다거나
- 특정 영업 시간대에만 락을 획득한다거나... 등등
### 🦆 4. Redisson Lock (Pub-Sub 기반)
- `Redisson 라이브러리`를 사용하여 제공되는 고수준 분산 락
- `AOP 방식으로 래핑한 커스텀 애노테이션(@DistributedLock)`을 만들면 편하다.
  - **@RedissonLock("lockName")** 같은 식으로 사용 가능